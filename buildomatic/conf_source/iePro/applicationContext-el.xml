<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xmlns:lang="http://www.springframework.org/schema/lang" 
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
       	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd
       	http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-3.1.xsd">

    <!--
            2014-03-31  thorick
                        note:  the 2 top level beans:  operatorDef and functionDef have opposite 'inMemory' defaults:

                               operatorDef:  inMemory == false    pushdown to DBMS
                               functionDef:  inMemory == true     calculate in memory

    -->
    <!--  put some commonly used types for validation here -->
    <!--  we've stretched the notion of ObjectType here to implement validation -->
    <util:map id="operatorTypes">
    	<entry key="level" value="#{ objectTypeMapper.checkType('String').acceptValues('Current', 'RowGroup', 'RowTotal', 'ColumnGroup', 'ColumnTotal', 'Total') }"/>
    </util:map>
    	
	<!-- operator definition is how we define available functions and their attributes; here is the base bean -->
    <bean id="operatorDef" class="com.jaspersoft.commons.dataset.expr.OperatorDefinitionImpl">
    	<property name="objectType" value="STRING"/>
    	<property name="objectTypeMapper" ref="objectTypeMapper"/>
    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.GenericFunction"/>
        <property name="inMemory" value="false"/>
	</bean>	
	
	<!-- here are some other beans that are used as parents for various other classes of operators -->
	<!-- comparison operators, which are broken into two groups:
	     equals and notEqual can compare numeric, date, and string
	     greater, less, etc. can only compare numeric and date (we are calling these "scalar" because they have values you can put on a scale)
	     At some point we could decide to allow all of them to compare strings, but for now let's differentiate them
	  -->
    <bean id="comparisonDef" parent="operatorDef" class="com.jaspersoft.commons.dataset.expr.ComparisonOperatorDefinition">
    	<property name="javaType" value="java.lang.Boolean"/>
    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.ComparisonOperator"/>
        <property name="argumentTypes">
            <list>
                <value>#{ objectTypeMapper.checkType('Comparable') }</value>
                <value>#{ objectTypeMapper.checkType('Comparable') }</value>
            </list>
        </property>
	</bean>	

    <bean id="scalarComparisonDef" parent="comparisonDef">
    	<property name="javaType" value="java.lang.Boolean"/>
    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.ComparisonOperator"/>
        <property name="argumentTypes">
            <list>
                <value>#{ objectTypeMapper.checkType('Scalar') }</value>
                <value>#{ objectTypeMapper.checkType('Scalar') }</value>
            </list>
        </property>
	</bean>	

	<!-- date comparison operators -->
    <bean id="dateComparisonDef" parent="operatorDef">
    	<property name="javaType" value="java.lang.Boolean"/>
    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.GenericFunction"/>
        <property name="inMemory" value="false"/>
	</bean>	

	<!-- in operator -->
    <bean id="inDef" parent="comparisonDef">
    	<property name="javaType" value="java.lang.Boolean"/>
    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.In"/>
    	<!-- TODO check that RHS of 'in' is list or range, and matches type -->
	</bean>	

	<!-- logical operators -->
    <bean id="logicalDef" parent="operatorDef">
    	<property name="javaType" value="java.lang.Boolean"/>
    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.LogicalOperator"/>
    	<property name="argumentTypes">
    		<list>
    			<value>#{ objectTypeMapper.checkType('Boolean').varArg() }</value> 
    		</list>
    	</property>
	</bean>	

	<!-- arithmetic operators (have their own operatorDef subclass which has the getJavaType logic in it)-->
	    <bean id="arithmeticDef" parent="operatorDef" class="com.jaspersoft.commons.dataset.expr.ArithmeticOperatorDefinition">
	    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.ArithmeticOperator"/>
	    	<property name="argumentTypes">
	    		<list>
	    			<value>#{ objectTypeMapper.checkType('Numeric') }</value>
	    			<value>#{ objectTypeMapper.checkType('Numeric') }</value>
	    		</list>
	    	</property>
		</bean>

	<!-- any other functions -->
    <bean id="functionDef" parent="operatorDef">
    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.GenericFunction"/>
	<property name="properties">
			<map>
				<!-- show in calc field dialog -->
				<entry key="inAvailableFunctions" value="true" />
			</map>
		</property>
        <property name="inMemory" value="true"/>
	</bean>

	<!-- aggregate operators (have custom getJavaType logic for sum and average) -->
	<bean id="aggregateDef" parent="functionDef" class="com.jaspersoft.commons.dataset.expr.AggregateOperatorDefinition">
		<property name="properties">
			<map merge="true">
				<entry key="aggregate" value="true" />
			</map>
		</property>
        <property name="inMemory" value="false"/>
	</bean>

	<!-- for agg ops on numerics (sum, etc)-->
	<bean id="numericAggregateDef" parent="aggregateDef">
		<property name="argumentTypes">
    		<list> 
    			<value>#{ objectTypeMapper.checkType('@Numeric') }</value>
    			<value>#{ operatorTypes['level'].optional() }</value>
    		</list>
    	</property>
        <property name="inMemory" value="false"/>
	</bean>
    
	<!-- for agg ops on any type (count, distinct count) -->
	<bean id="anyAggregateDef" parent="aggregateDef">
		<property name="argumentTypes">
    		<list> 
    			<value>#{ objectTypeMapper.checkType('@Any') }</value>
    			<value>#{ operatorTypes['level'].optional() }</value>
    		</list>
    	</property>
        <property name="inMemory" value="false"/>
	</bean>
    
	<!-- for agg ops on date types (ranges) -->
	<bean id="dateAggregateDef" parent="aggregateDef">
		<property name="argumentTypes">
    		<list> 
    			<value>#{ objectTypeMapper.checkType('@DateTime') }</value>
    			<value>#{ operatorTypes['level'].optional() }</value>
    		</list>
    	</property>
        <property name="inMemory" value="false"/>
	</bean>
    
	<!-- for agg ops on date and numeric types (min, max, etc) -->
	<bean id="comparableAggregateDef" parent="aggregateDef">
		<property name="argumentTypes">
    		<list> 
    			<value>#{ objectTypeMapper.checkType('@Scalar') }</value>
    			<value>#{ operatorTypes['level'].optional() }</value>
    		</list>
    	</property>
        <property name="inMemory" value="true"/>
	</bean>
    
	<!-- date diff functions (in memory) -->
	    <bean id="dateDiffFunctionDef" parent="operatorDef">
	    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.GenericFunction"/>
	    	<property name="javaType" value="java.math.BigDecimal"/>
	    	<property name="argumentTypes">
	    		<list>
	    			<value>#{ objectTypeMapper.checkType('DateTime') }</value>
	    			<value>#{ objectTypeMapper.checkType('DateTime') }</value>
	    		</list>
	    	</property>
            <property name="inMemory" value="true"/>
		</bean>

    <bean id="elapsedTimeFunctionDef" parent="dateDiffFunctionDef">
        <property name="properties">
            <map merge="true">
                <!-- show in calc field dialog -->
                <entry key="inAvailableFunctions" value="true" />
            </map>
        </property>
	</bean>

    <bean id="rangeTimeFunctionDef" parent="operatorDef">
         <property name="objectTypeMapper" ref="objectTypeMapper"/>
       	 <property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.GenericFunction"/>
         <property name="javaType" value="java.math.BigDecimal"/>
         <property name="properties">
             <map merge="true">
                 <!-- specifically DO NOT show in calc field function dialog, leave out the property entirely
                 <entry key="inAvailableFunctions" value="true" />
                 -->
             </map>
         </property>
         <!-- these can have their args pushed down...see PushdownerImpl -->
         <property name="inMemory" value="false"/>
 	</bean>


	<!-- string match functions -->
    <bean id="stringMatchDef" parent="functionDef">
    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.StringMatchOperator"/>
    	<property name="javaType" value="java.lang.Boolean"/>
		<property name="argumentTypes">
    		<list> 
    			<value>#{ objectTypeMapper.checkType('String') }</value>
    			<value>#{ objectTypeMapper.checkType('String') }</value>
    		</list>
    	</property>
        <property name="inMemory" value="false"/>
	</bean>	
	
	<!-- percent functions (in memory, aggregate arg) -->
    <bean id="percentFunctionDef" parent="operatorDef">
    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.GenericFunction"/>
    	<property name="javaType" value="java.lang.Double"/>
    	<property name="argumentTypes">
    		<list>
    			<value>#{ objectTypeMapper.checkType('@Numeric') }</value>
    		</list>
    	</property>
        <property name="properties">
             <map>
                 <!-- hide from calc field dialog -->
                 <entry key="inAvailableFunctions" value="false" />
                 <!-- aggregate percentages by sum -->
                 <entry key="argumentAggregateFunction" value="sum" />
             </map>
        </property>
        <property name="inMemory" value="true"/>
	</bean>	

    <!-- re-cast percentFunctions as of JRS release 5.6 -->
    <bean id="percentFunctionDef56" parent="percentFunctionDef">
        <property name="properties">
             <map merge="true">
                 <!-- show in calc field dialog -->
                 <entry key="inAvailableFunctions" value="true" />
             </map>
        </property>
		<property name="argumentTypes">
    		<list> 
    			<value>#{ objectTypeMapper.checkType('@Numeric') }</value>
    			<!-- optional? -->
    			<value>#{ operatorTypes['level'].optional() }</value>
    		</list>
    	</property>
    </bean>
    <!-- convenience bean for audit function defs: all in SQL, none should be in avail functions -->
	<bean id="auditFunctionDef" parent="functionDef">
		<property name="properties">
			<map>
				<!-- do NOT show in calc field dialog -->
				<entry key="inAvailableFunctions" value="false" />
			</map>
		</property>
		<property name="inMemory" value="false" />
	</bean>

    <!-- 
        This is the "parent", or template bean, for all expression evaluators.
        The base class is used for evaluating expressions in the schema.
      -->
    <bean id="expressionEvaluator" class="com.jaspersoft.commons.dataset.expr.ExpressionEvaluator" scope="prototype">
        <!-- match sl config -->
        <property name="dateFormat" value="MMM dd yyyy"/>

        <property name="objectTypeMapper" ref="objectTypeMapper"/>

        <!-- list of ScopeInitter impls that can mess around with the evaluator -->
        <property name="scopeInitterList">
            <list/>
        </property>
        <!-- generic expression factory -->
        <property name="expressionFactory">
            <bean class="com.jaspersoft.commons.dataset.expr.GenericExpressionFactory">
            
            	<!-- 
            		DomEL functions can be registered here. This is only for metadata currently; any implementations are elsewhere.
            		And for now, the only metadata is the objectType returned by the expression.
            		ObjectType is an "abstract type" used by DomEL; see objectTypeMapper bean (below) for the mapping to Java types.
            	 -->
                <property name="functionList">
                	<list>
                	</list>
              	</property>
              	<!-- operatorDefinition is the new way of enumerating operators -->
              	              	
                <property name="operatorDefinitionList">
                	<list>
                		<!-- comparison (see above for why they're in separate groups) -->
                	    <bean parent="comparisonDef">
                	    	<property name="name" value="equals"/>
                	    	<property name="symbol" value="=="/>
                		</bean>	
                	    <bean parent="comparisonDef">
                	    	<property name="name" value="notEqual"/>
                	    	<property name="symbol" value="!="/>
                		</bean>	
                	    <bean parent="scalarComparisonDef">
                	    	<property name="name" value="greaterOrEqual"/>
                	    	<property name="symbol" value="&gt;="/>
                		</bean>	
                	    <bean parent="scalarComparisonDef">
                	    	<property name="name" value="lessOrEqual"/>
                	    	<property name="symbol" value="&lt;="/>
                		</bean>	
                	    <bean parent="scalarComparisonDef">
                	    	<property name="name" value="greater"/>
                	    	<property name="symbol" value="&gt;"/>
                		</bean>	
                	    <bean parent="scalarComparisonDef">
                	    	<property name="name" value="less"/>
                	    	<property name="symbol" value="&lt;"/>
                		</bean>	

                		<!-- logical -->
                	    <bean parent="logicalDef">
                	    	<property name="name" value="and"/>
                		</bean>	
                	    <bean parent="logicalDef">
                	    	<property name="name" value="or"/>
                		</bean>	

                		<!-- in -->
                	    <bean parent="inDef">
                	    	<property name="name" value="in"/>
                		</bean>	
                		
                		<!-- arithmetic	-->
                	    <bean parent="arithmeticDef">
                	    	<property name="name" value="add"/>
                	    	<property name="symbol" value="+"/>
                		</bean>	
                	    <bean parent="arithmeticDef">
                	    	<property name="name" value="subtract"/>
                	    	<property name="symbol" value="-"/>
                		</bean>	
                	    <bean parent="arithmeticDef">
                	    	<property name="name" value="multiply"/>
                	    	<property name="symbol" value="*"/>
                		</bean>	
                	    <bean parent="arithmeticDef">
                	    	<property name="name" value="divide"/>
                	    	<property name="symbol" value="/"/>
                		</bean>	
                        <!--  percentFieldRatio is the percentage of one field compared to another
                                 ( a / b ) * 100
                        -->
                        <bean parent="arithmeticDef">
                    	    <property name="name" value="percentFieldRatio"/>
                            <property name="symbol" value="%"/>
                        </bean>
                		
                		<!-- string match -->
                	    <bean parent="stringMatchDef">
                	    	<property name="name" value="StartsWith"/>
                            <property name="alias" value="startsWith"/>
                		</bean>	
                	    <bean parent="stringMatchDef">
                	    	<property name="name" value="EndsWith"/>
                            <property name="alias" value="endsWith"/>
                		</bean>	
                	    <bean parent="stringMatchDef">
                	    	<property name="name" value="Contains"/>
                            <property name="alias" value="contains"/>
                		</bean>	
                		
                		<!-- relative dates -->
                	    <bean parent="dateComparisonDef">
                	    	<property name="name" value="equalsDate"/>
                		</bean>	
                	    <bean parent="dateComparisonDef">
                	    	<property name="name" value="afterDate"/>
                		</bean>	
                	    <bean parent="dateComparisonDef">
                	    	<property name="name" value="beforeDate"/>
                		</bean>	
                	    <bean parent="dateComparisonDef">
                	    	<property name="name" value="isOnOrAfterDate"/>
                		</bean>	
                	    <bean parent="dateComparisonDef">
                	    	<property name="name" value="isOnOrBeforeDate"/>
                		</bean>	
                	    <bean parent="dateComparisonDef">
                	    	<property name="name" value="betweenDates"/>
                		</bean>	
                		
                		<!-- misc -->
                	    <bean parent="functionDef">
                	    	<property name="name" value="Length"/>
    						<property name="javaType" value="java.lang.Integer"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('String') }</value>
					    		</list>
					    	</property>
                            <property name="alias" value="length"/>
                            <property name="inMemory" value="false"/>
                		</bean>	
						<!-- isNull(), str2int(), date(), time() are used in audit domain
						     They're not "official" so don't show in available functions (except IsNull) -->
						<!-- isNull(): nuff said -->
                	    <bean parent="functionDef">
                	    	<property name="name" value="IsNull"/>
    						<property name="javaType" value="java.lang.Boolean"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('Any') }</value>
					    		</list>
					    	</property>
                            <property name="alias" value="isNull"/>
                            <property name="inMemory" value="false"/>
                		</bean>
						<!-- str2int(): parse a string, return int -->
                	    <bean parent="auditFunctionDef">
                	    	<property name="name" value="str2int"/>
    						<property name="javaType" value="java.lang.Integer"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('String') }</value>
					    		</list>
					    	</property>
                		</bean>
						<!-- date(): get date from a timestamp -->
                	    <bean parent="auditFunctionDef">
                	    	<property name="name" value="date"/>
    						<property name="javaType" value="java.util.Date"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('Timestamp') }</value>
					    		</list>
					    	</property>
                		</bean>
						<!-- time(): get time part from a timestamp (but audit still expects Timestamp type, go figure) -->
                	    <bean parent="auditFunctionDef">
                	    	<property name="name" value="time"/>
    						<property name="javaType" value="java.sql.Timestamp"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('Timestamp') }</value>
					    		</list>
					    	</property>
                		</bean>

                        <bean parent="functionDef">
                            <property name="name" value="Round"/>
     						<property name="javaType" value="java.lang.Double"/>
                            <property name="aliases">
                                <list>
                                    <value>round</value>
                                </list>
                            </property>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('Numeric') }</value>
					    			<value>#{ objectTypeMapper.checkType('Integer').optional() }</value>
					    		</list>
					    	</property>
                            <property name="inMemory" value="false"/>
                         </bean>

                        <!-- 'Today' is new for v5.6 and should be considered different than lower case no argument 'today' -->
                        <bean parent="functionDef">
                    	    <property name="name" value="Today"/>
                            <property name="javaType" value="java.util.Date"/>
    					    <property name="argumentTypes">
                                <list>
                                    <value>#{ objectTypeMapper.checkType('Integer').optional() }</value>
                                </list>
    					    </property>
                        </bean>

                        <bean parent="functionDef">
                            <property name="name" value="Absolute"/>
                            <property name="aliases">
                                <list>
                                    <value>abs</value>
                                    <value>Abs</value>
                                </list>
                            </property>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('Numeric') }</value>
					    		</list>
					    	</property>
                        </bean>

						<!-- "if" has custom getJavaType() and validate() -->
                        <bean parent="functionDef" class="com.jaspersoft.commons.dataset.expr.IfOperatorDefinition">
                            <property name="name" value="IF"/>
                            <property name="aliases">
                                <list>
                                    <value>if</value>
                                    <value>If</value>
                                </list>
                            </property>
                            <property name="inMemory" value="false"/>
                        </bean>

                        <!-- Mid  is the Excell name for 'substring' -->
                        <bean parent="functionDef">
                            <property name="name" value="Mid"/>
                	    	<property name="alias" value="substr"/>
      						<property name="javaType" value="java.lang.String"/>
					    	<property name="argumentTypes">
					    		<list>
                                    <value>#{ objectTypeMapper.checkType('String') }</value>
					    			<value>#{ objectTypeMapper.checkType('Integer') }</value>
					    			<value>#{ objectTypeMapper.checkType('Integer').optional() }</value>
					    		</list>
					    	</property>
                            <property name="inMemory" value="false"/>
                         </bean>

                        <bean parent="functionDef">
                            <property name="name" value="Least"/>
                            <property name="alias" value="least"/>
                            <property name="properties">
                            	<map>
                            		<!-- do NOT show in calc field dialog -->
                            		<entry key="inAvailableFunctions" value="false" />
                            	</map>
                            </property>
                            <property name="inMemory" value="false"/>                            
                        </bean>
                        <bean parent="functionDef">
                            <property name="name" value="Greatest"/>
                            <property name="alias" value="greatest"/>
                            <property name="properties">
                            	<map>
                            		<!-- do NOT show in calc field dialog -->
                            		<entry key="inAvailableFunctions" value="false" />
                            	</map>
                            </property>
                            <property name="inMemory" value="false"/>                                                        
                        </bean>


                        <!-- dummy concatenate, here solely to provide metadata
                              concatenate has no explicit 'method' named 'concatenate'
                              that defines the function
                        -->
                        <bean parent="functionDef">
                            <property name="name" value="Concatenate"/>
                            <property name="aliases">
                                <list>
                                    <value>concat</value>
                                </list>
                            </property>
                            <property name="javaType" value="java.lang.String"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('Any') }</value>
					    			<value>#{ objectTypeMapper.checkType('Any').varArg() }</value>
					    		</list>
					    	</property>
                            <property name="inMemory" value="false"/>
                         </bean>


                        <bean parent="functionDef">
                            <property name="name" value="MonthName"/>
                            <property name="javaType" value="java.lang.String"/>
                            <property name="inMemory" value="true"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('DateTime') }</value>
					    		</list>
					    	</property>
                        </bean>
                        <bean parent="functionDef">
                            <property name="name" value="DayName"/>
                            <property name="javaType" value="java.lang.String"/>
                            <property name="inMemory" value="true"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('DateTime') }</value>
					    		</list>
					    	</property>
                        </bean>

                        <bean parent="functionDef">
                            <property name="name" value="Year"/>
                            <property name="alias" value="year"/>
                            <property name="javaType" value="java.lang.Integer"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('DateTime') }</value>
					    		</list>
					    	</property>
                            <property name="inMemory" value="false"/>
                        </bean>
                        <bean parent="functionDef">
                            <property name="name" value="MonthNumber"/>
                            <property name="alias" value="month"/>
                            <property name="javaType" value="java.lang.Integer"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('DateTime') }</value>
					    		</list>
					    	</property>
                            <property name="inMemory" value="false"/>
                        </bean>
                        <bean parent="functionDef">
                            <property name="name" value="DayNumber"/>
                            <property name="alias" value="day"/>
                            <property name="javaType" value="java.lang.Integer"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('DateTime') }</value>
					    		</list>
					    	</property>
                            <property name="inMemory" value="false"/>
                        </bean>

						<!-- hour, minute, and second are pre-existing SQL functions on timestamps that can be used in domains. -->
                        <bean parent="functionDef">
                            <property name="name" value="hour"/>
                            <property name="alias" value="Hour"/>
                            <property name="javaType" value="java.lang.Integer"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('Timestamp') }</value>
					    		</list>
					    	</property>
							<property name="properties">
								<map>
									<!-- don't show in calc field dialog -->
									<entry key="inAvailableFunctions" value="false" />
									<!-- always run in SQL -->
                                    <entry key="alwaysInSQL" value="true" />
								</map>
							</property>
                            <property name="inMemory" value="false"/>
                        </bean>

                        <bean parent="functionDef">
                            <property name="name" value="minute"/>
                            <property name="alias" value="Minute"/>
                            <property name="javaType" value="java.lang.Integer"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('Timestamp') }</value>
					    		</list>
					    	</property>
							<property name="properties">
								<map>
									<!-- don't show in calc field dialog -->
									<entry key="inAvailableFunctions" value="false" />
									<!-- always run in SQL -->
                                    <entry key="alwaysInSQL" value="true" />
								</map>
							</property>
                            <property name="inMemory" value="false"/>
                        </bean>

                        <bean parent="functionDef">
                            <property name="name" value="second"/>
                            <property name="alias" value="Second"/>
                            <property name="javaType" value="java.lang.Integer"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('Timestamp') }</value>
					    		</list>
					    	</property>
							<property name="properties">
								<map>
									<!-- don't show in calc field dialog -->
									<entry key="inAvailableFunctions" value="false" />
									<!-- always run in SQL -->
                                    <entry key="alwaysInSQL" value="true" />
								</map>
							</property>
                            <property name="inMemory" value="false"/>
                        </bean>

						<!-- experimental -->
                        <bean parent="functionDef">
                            <property name="name" value="addInterval"/>
                            <property name="javaType" value="java.util.Date"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('DateTime') }</value>
					    			<value>#{ objectTypeMapper.checkType('String') }</value>
					    		</list>
					    	</property>
							<property name="properties">
								<map>
									<!-- don't show in calc field dialog -->
									<entry key="inAvailableFunctions" value="false" />
								</map>
							</property>
                            <property name="inMemory" value="false"/>
                        </bean>

						<!-- aggregates (tbd: add arg types) -->
                        <!-- sum and average need to go to the next highest type (logic is in AggregateOperatorDefinition) -->

                        <bean parent="numericAggregateDef">
                             <property name="name" value="Sum"/>
                             <property name="alias" value="sum"/>
                         </bean>

                        <bean parent="numericAggregateDef">
                            <property name="name" value="Average"/>
                            <property name="aliases">
                                <list>
                                    <value>average</value>
                                    <value>avg</value>
                                </list>
                            </property>
                        </bean>

                        <bean parent="anyAggregateDef">
                            <property name="name" value="CountAll"/>
    						<property name="javaType" value="java.lang.Long"/>
                            <property name="aliases">
                                <list>
                                    <value>count</value>
                                    <value>Count</value>
                                </list>
                            </property>
                        </bean>
                        
                        <!-- experimental -->
                        <bean parent="anyAggregateDef">
                            <property name="name" value="CountIf"/>
    						<property name="javaType" value="java.lang.Long"/>
					    	<property name="argumentTypes">
					    		<list>
					    			<value>#{ objectTypeMapper.checkType('@Boolean') }</value>
					    			<value>#{ operatorTypes['level'].optional() }</value>
					    		</list>
					    	</property>
							<property name="properties">
								<map>
									<!-- don't show in calc field dialog -->
									<entry key="inAvailableFunctions" value="false" />
								</map>
							</property>
                            <property name="inMemory" value="true"/>
                        </bean>

                        <bean parent="anyAggregateDef">
                            <property name="name" value="CountDistinct"/>
    						<property name="javaType" value="java.lang.Long"/>
                            <property name="aliases">
                                <list>
                                    <value>distinctCount</value>
                                    <value>DistinctCount</value>
                                </list>
                            </property>
                        </bean>

                        <!-- for min and max, type is same as type of argument, which is default behavior -->

                        <bean parent="comparableAggregateDef">
                            <property name="name" value="Min"/>
                            <property name="aliases">
                                <list>
                                    <value>min</value>
                                    <value>Lowest</value>
                                    <value>Minimum</value>
                                </list>
                            </property>
                        </bean>
                        <bean parent="comparableAggregateDef">
                            <property name="name" value="Max"/>
                            <property name="aliases">
                                <list>
                                    <value>max</value>
                                    <value>Highest</value>
                                    <value>Maximum</value>
                                </list>
                            </property>
                        </bean>

                        <bean parent="numericAggregateDef">
                            <property name="name" value="Range"/>
                        </bean>
                        <bean parent="anyAggregateDef">
                            <property name="name" value="Mode"/>
                            <property name="inMemory" value="true"/>
                        </bean>
                        <bean parent="comparableAggregateDef">
                            <property name="name" value="Median"/>
                        </bean>
                        <bean parent="numericAggregateDef">
                            <property name="name" value="StdDevP"/>
                            <property name="inMemory" value="true"/>
                        </bean>
                        <bean parent="numericAggregateDef">
                            <property name="name" value="StdDevS"/>
                            <property name="inMemory" value="true"/>
                        </bean>

                        <!-- asInterval is defined as an aggregate, so that the same function can be called to format
                             things and return a string whether it's detail or agg data
                          -->
                        <bean parent="dateAggregateDef">
                            <property name="name" value="asInterval"/>
					    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.GenericFunction"/>
					    	<property name="javaType" value="java.lang.String"/>
					    	<property name="properties">
								<map>
									<!-- hide from calc field dialog -->
									<entry key="inAvailableFunctions" value="false" />
								</map>
							</property>
                            <property name="inMemory" value="true"/>
						</bean>	
                        
                        <!-- date diff functions -->
                        <bean parent="dateDiffFunctionDef">
                            <property name="name" value="dateDiffInSeconds"/>
                        </bean>
                        <bean parent="dateDiffFunctionDef">
                            <property name="name" value="dateDiffInMinutes"/>
                        </bean>
                        <bean parent="dateDiffFunctionDef">
                            <property name="name" value="dateDiffInHours"/>
                        </bean>
                        <bean parent="dateDiffFunctionDef">
                            <property name="name" value="dateDiffInDays"/>
                        </bean>
                        <bean parent="dateDiffFunctionDef">
                            <property name="name" value="dateDiffInWeeks"/>
                        </bean>
                        <bean parent="dateDiffFunctionDef">
                            <property name="name" value="dateDiffInMonths"/>
                        </bean>
                        <bean parent="dateDiffFunctionDef">
                            <property name="name" value="dateDiffInQuarters"/>
                        </bean>
                        <bean parent="dateDiffFunctionDef">
                            <property name="name" value="dateDiffInYears"/>
                        </bean>

                        <!--  re-named date diff functions.
                              As of release 5.6:
                              New name: elapsed<Period>
                        -->

                        <bean parent="elapsedTimeFunctionDef">
                            <property name="name" value="ElapsedSeconds"/>
                        </bean>
                        <bean parent="elapsedTimeFunctionDef">
                            <property name="name" value="ElapsedMinutes"/>
                        </bean>
                        <bean parent="elapsedTimeFunctionDef">
                            <property name="name" value="ElapsedHours"/>
                        </bean>
                        <bean parent="elapsedTimeFunctionDef">
                            <property name="name" value="ElapsedDays"/>
                        </bean>
                        <bean parent="elapsedTimeFunctionDef">
                            <property name="name" value="ElapsedWeeks"/>
                        </bean>
                        <bean parent="elapsedTimeFunctionDef">
                            <property name="name" value="ElapsedMonths"/>
                        </bean>
                        <bean parent="elapsedTimeFunctionDef">
                            <property name="name" value="ElapsedQuarters"/>
                         </bean>
                        <bean parent="elapsedTimeFunctionDef">
                            <property name="name" value="ElapsedSemis"/>
                        </bean>
                        <bean parent="elapsedTimeFunctionDef">
                            <property name="name" value="ElapsedYears"/>
                        </bean>


                        <bean parent="rangeTimeFunctionDef">
                            <property name="name" value="RangeMinutes"/>
                        </bean>
                        <bean parent="rangeTimeFunctionDef">
                            <property name="name" value="RangeHours"/>
                        </bean>
                        <bean parent="rangeTimeFunctionDef">
                            <property name="name" value="RangeDays"/>
                        </bean>
                        <bean parent="rangeTimeFunctionDef">
                            <property name="name" value="RangeWeeks"/>
                        </bean>
                        <bean parent="rangeTimeFunctionDef">
                            <property name="name" value="RangeMonths"/>
                        </bean>
                        <bean parent="rangeTimeFunctionDef">
                            <property name="name" value="RangeQuarters"/>
                         </bean>
                        <bean parent="rangeTimeFunctionDef">
                            <property name="name" value="RangeSemis"/>
                        </bean>
                        <bean parent="rangeTimeFunctionDef">
                            <property name="name" value="RangeYears"/>
                        </bean>

						<!-- some other in-memory functions -->
                	    <bean parent="functionDef">
                	    	<property name="name" value="Rank"/>
                	    	<property name="inMemory" value="true"/>
    						<property name="javaType" value="java.lang.Integer"/>
                            <property name="alias"  value="rank"/>
                	    	<!--  as currently implemented this doesn't behave as a proper aggregate aware measure;
                	    	      for now, make it backwards compatible -->
                	    	      
					    	<property name="argumentTypes">
					    		<list> 
					    			<value>#{ objectTypeMapper.checkType('Numeric') }</value>
					    		</list>
					    	</property>
                		</bean>	
                		
                		<!-- percent functions -->

                        <!--
                             pre-v5.6 percent functions

                             'percent' is 'percent of Total'

                             we have to retain all old functions here so that we can load
                             old pre-v5.6  Views
                        -->
                	    <bean parent="percentFunctionDef">
                	    	<property name="name" value="percent"/>
                		</bean>	
                	    <bean parent="percentFunctionDef">
                	    	<property name="name" value="percentOfRowParent"/>
                		</bean>	
                	    <bean parent="percentFunctionDef">
                	    	<property name="name" value="percentOfColumnParent"/>
                		</bean>	
                	    <bean parent="percentFunctionDef">
                	    	<property name="name" value="percentOfRow"/>
                		</bean>	
                	    <bean parent="percentFunctionDef">
                	    	<property name="name" value="percentOfColumn"/>
                		</bean>


                        <!--
                              2014-01-23  thorick

                              PercentOf function v5.6 and later.
                              PercentOf has become a basic function name
                              with a 'Level' parameter indicating the scope
                              of the base data used in the calculation:
                                  RowGroup, RowTotal, Total, etc...
                        -->
                        <bean parent="percentFunctionDef56">
                            <property name="name" value="PercentOf"/>
					        <!-- PercentOf can have its args pushed down...see PushdownerImpl -->
					        <property name="inMemory" value="false"/>
                        </bean>

                        <bean parent="percentFunctionDef56">
                            <property name="name" value="WeightedAverage"/>
							<property name="argumentTypes">
					    		<list> 
					    			<value>#{ objectTypeMapper.checkType('@Numeric') }</value>
					    			<value>#{ objectTypeMapper.checkType('@Numeric') }</value>
					    			<value>#{ operatorTypes['level'].optional() }</value>
					    		</list>
					    	</property>
                        </bean>

                        <!-- fallback used when no other defs found
                            Bug 37889:
                            Prior to 5.6, we supported using arbitrary functions in calc fields or filters in a domain schema.
                            These functions would be mapped directly to SQL, so this would work as long as the DB supported the use of that function.
                            To support this functionality, assume that any functions not otherwise defined must be done in the SQL query.

                            This may not be enough to get the functions to work, because the default definition might return the wrong type.
                            To support the function, add an extra entry here for the function, and set the javaType property appropriately.
                            See the "hex" function below for an example.
                        -->

					    <bean parent="operatorDef">
					    	<property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.GenericFunction"/>
                	    	<property name="name" value="_default"/>
					    	<property name="properties">
								<map>
									<!-- set this property so you can validate for invalid functions -->
									<entry key="invalid" value="true" />

                                    <!--
                                        http://bugzilla.jaspersoft.com/show_bug.cgi?id=37889

                                        reinstate handling of _default by punting and
                                        pushing ANY unknown function operator down
                                        to SQL verbatim
                                    -->
                                    <entry key="alwaysInSQL" value="true" />
								</map>
							</property>
                        </bean>


                        <!--  example "hex" function done in SQL ("hex" is MySQL-specific and returns the hex value of an integer as a string)
                            note that in this example, specifying the return 'javaType' property was required for this
                            function to work properly.
                            Some (most ?) cases can be handled without any specially defined operator, like 'hex', by deferring to
                            the operatorDef named '_default'.
                        -->
                        <bean parent="operatorDef">
                            <property name="operatorClass" value="com.jaspersoft.commons.dataset.expr.GenericFunction"/>
                            <property name="name" value="hex"/>
                            <property name="javaType" value="java.lang.String"/>
                            <property name="properties">
                                <map>
                                    <!-- set this property so you can validate for invalid functions -->
                                    <entry key="invalid" value="true" />
                                    <entry key="alwaysInSQL" value="true" />
                                </map>
                            </property>
                        </bean>

                	</list>
              	</property>
                <!-- 
					functionMap doesn't work any more; create an operator definition instead
                  -->
                <property name="functionMap">
                    <map/>
                </property>
                <property name="formatTimestampInGMT" ref="saveTimestampFilterInGMT" />
            </bean>
        </property>
        
        <!-- hook for function metadata -->
        <property name="functionFilter" ref="domELMetadataHelper"/>
        <!-- supplies various functions around validation -->
        <property name="expressionValidator" ref="domELMetadataHelper"/>
        <!-- name to create pushdown transformer -->
        <property name="pushdownBean" value="pushdowner"/>
        
    </bean>

    <!-- this map is shared among several beans so I'm breaking it out to make life easier -->

    <bean id="objectTypeMapper" class="com.jaspersoft.commons.dataset.expr.ObjectTypeMapper">
        <property name="objectTypeMap">
            <map>
                <entry key="java.lang.String" value="String"/>
                
                <entry key="java.lang.Character" value="Character"/>
                
				<!-- these should be in order from smaller to bigger -->
                <entry key="java.lang.Byte" value="Integer"/>
                <entry key="java.lang.Short" value="Integer"/>
                <entry key="java.lang.Integer" value="Integer"/>
                <entry key="java.lang.Long" value="Integer"/>
                <entry key="java.math.BigInteger" value="Integer"/>
                
				<!-- these should be in order from smaller to bigger -->
                <entry key="java.lang.Number" value="Decimal"/>
                <entry key="java.lang.Float" value="Decimal"/>
                <entry key="java.lang.Double" value="Decimal"/>
                <entry key="java.math.BigDecimal" value="Decimal"/>
                
                <entry key="java.util.Date" value="Date"/>
                <entry key="java.sql.Date" value="Date"/>
                
                <entry key="java.sql.Time" value="Time"/>
                
                <entry key="java.sql.Timestamp" value="Timestamp"/>

                <entry key="java.lang.Boolean" value="Boolean"/>

                <entry key="org.springframework.security.Authentication" value="Authentication"/>
                <entry key="java.util.Map" value="Map"/>
                <entry key="java.util.Collection" value="Collection"/>
            </map>
        </property>
        
        <!-- type to use for various operators to upgrade types -->
    	<property name="nextBiggestTypeMap">
    		<map>
    			<entry key="java.lang.Byte" value="java.lang.Short"/>
    			<entry key="java.lang.Short" value="java.lang.Integer"/>
    			<entry key="java.lang.Integer" value="java.lang.Long"/>
    			<entry key="java.lang.Float" value="java.lang.Double"/>
    		</map>
    	</property>
        
    </bean>

	<!-- bean with a bunch of type classification code which duplicates ObjectTypeMapper -->
	<bean id="typeUtil" class="com.jaspersoft.commons.dataset.expr.TypeUtil">
		<property name="typeMapper" ref="objectTypeMapper"/>
	</bean>
	
	<!-- 
		this bean has some functions which control various aspects of DomEL that are needed for calc fields:
		- list DomEL function metadata
		- provide control over forming aggregate expressions
	  -->
    <lang:groovy id="domELMetadataHelper"
                 refresh-check-delay="5000"
                 script-source="${resource.root}/groovy/com/jaspersoft/commons/dataset/expr/DomELMetadataHelper.groovy">
    </lang:groovy>
	<!--  this bean does pushdown transforms -->
    <lang:groovy id="pushdowner"
                 refresh-check-delay="5000"
                 script-source="${resource.root}/groovy/com/jaspersoft/commons/dataset/expr/PushdownerImpl.groovy">
    </lang:groovy>
	
</beans>
